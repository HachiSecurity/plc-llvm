-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package plc-llvm
@version 0.2.1

module Hachi.Compiler.CodeGen.Constant.String
globalStrs :: [(String, String)]

module Hachi.Compiler.CodeGen.Externals.Utility

-- | <a>globalFromType</a> <tt>name type</tt> constructs a <a>Global</a>
--   given its <tt>name</tt> and <tt>type</tt>.
globalFromType :: String -> Type -> Global

module Hachi.Compiler.Config
data Config
MkConfig :: FilePath -> Maybe FilePath -> Maybe FilePath -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Maybe FilePath -> Maybe Word -> Config
[cfgInput] :: Config -> FilePath
[cfgOutput] :: Config -> Maybe FilePath
[cfgRTS] :: Config -> Maybe FilePath

-- | Is the input a binary file that must be deserialised?
[cfgDeserialise] :: Config -> Bool

-- | Is the input typed?
[cfgTyped] :: Config -> Bool

-- | Should the resulting LLVM code print diagnostic information?
[cfgTrace] :: Config -> Bool

-- | Should the compiler print diagnostic information while running?
[cfgVerbose] :: Config -> Bool

-- | Should the compiler generate an object file?
[cfgNoAssemble] :: Config -> Bool

-- | Should the compiler generate an executable?
[cfgNoLink] :: Config -> Bool

-- | Should the LLVM IR be in plain-text?
[cfgNoSerialise] :: Config -> Bool

-- | Should the generated code check for OOM after every malloc?
[cfgCheckOOM] :: Config -> Bool

-- | Should we produce a library?
[cfgLibrary] :: Config -> Bool

-- | If --library is specified, an optional path to a .c source file which
--   contains the entry point for the program.
[cfgEntryPoint] :: Config -> Maybe FilePath

-- | An optional value indicating what set of optimisations should be
--   applied to the program.
[cfgOptimisationLevel] :: Config -> Maybe Word

-- | <a>mkDefaultConfig</a> <tt>input</tt> constructs a <a>Config</a> with
--   reasonable defaults and using <tt>input</tt> as the input source file.
mkDefaultConfig :: FilePath -> Config

-- | <a>parseCmdLineArgs</a> parses command-line arguments into a
--   <a>Config</a> value. If parsing fails, the program is terminated and a
--   help message is shown.
parseCmdLineArgs :: IO Config
instance GHC.Show.Show Hachi.Compiler.Config.Config
instance GHC.Classes.Eq Hachi.Compiler.Config.Config

module Hachi.Compiler.CodeGen.Driver

-- | <a>runDriver</a> <tt>config pkgConfigArgs clangArgs</tt> runs Clang
--   with arguments given by <tt>clangArgs</tt> and additional arguments
--   obtained by running pkg-config with the arguments given by
--   <tt>pkgConfigArgs</tt> for all of our dependencies.
runDriver :: Config -> [String] -> [String] -> IO ()

-- | <a>buildObjectFile</a> <tt>config sourceFile</tt> uses Clang to
--   compile the source file at <tt>sourceFile</tt> to an object file. The
--   path of the generated object file is returned.
buildObjectFile :: Config -> FilePath -> IO FilePath

-- | <a>linkExecutable</a> <tt>config outputName objectFiles</tt> runs
--   Clang to produce an executable using the configuration given by
--   <tt>config</tt>, where <tt>outputName</tt> is the path we computed for
--   the output, and <tt>objectFiles</tt> are the paths of the object files
--   that we want to link together.
linkExecutable :: Config -> FilePath -> [FilePath] -> IO ()

module Hachi.Compiler.FreeVars

-- | <a>freeVars</a> <tt>term</tt> calculates the set of free variables for
--   <tt>term</tt>. For some reason, this function does not seem to exist
--   in the plutus libraries (it does exist for typed plutus and plutus IR
--   though).
freeVars :: Ord name => Term name uni fun ann -> Set name


-- | This module exports platform-specific information.
module Hachi.Compiler.Platform
platformPtrSize :: Num a => a
platformIntSize :: Num a => a
platformUnsignedLongIntSize :: Num a => a
platformGmpLimbSize :: Num a => a
platformGmpSize :: Num a => a
iHost :: Type
iUnsignedLongInt :: Type
gmpLimb :: Type


-- | This module contains various LLVM <a>Type</a> values used in the code
--   generator.
module Hachi.Compiler.CodeGen.Types

-- | <a>isPtr</a> <tt>type</tt> determines whether <tt>type</tt> represents
--   a pointer type.
isPtr :: Type -> Bool
i1 :: Type
i8 :: Type
i32 :: Type
i64 :: Type
ptrOf :: Type -> Type
char :: Type
stringPtr :: String -> Type

-- | <a>asStringPtr</a> <tt>constant</tt> casts <tt>constant</tt> to a char
--   pointer.
asStringPtr :: Constant -> Constant

-- | <a>bytestringTyDef</a> is the type definition for bytestrings.
bytestringTyDef :: Type

-- | <a>bytestringTy</a> is a <a>Type</a> for bytestrings.
bytestringTy :: Type

-- | <a>bytestringTyPtr</a> is a <a>Type</a> representing a pointer to a
--   bytestring.
bytestringTyPtr :: Type

-- | <a>pairTyDef</a> is the type definition for pairs.
pairTyDef :: Type

-- | <a>pairTy</a> is a <a>Type</a> for pairs.
pairTy :: Type

-- | <a>pairTyPtr</a> is a <a>Type</a> representing a pointer to a pair.
pairTyPtr :: Type

-- | <a>listTyDef</a> is the type definition for lists.
listTyDef :: Type

-- | <a>listTy</a> is a <a>Type</a> for lists.
listTy :: Type

-- | <a>listTyPtr</a> is a <a>Type</a> representing a pointer to a list.
listTyPtr :: Type

-- | Represents a pointer to a linked list.
newtype ListPtr
MkListPtr :: Operand -> ListPtr
[listPtr] :: ListPtr -> Operand

-- | The Plutus <tt>Data</tt> type is a sum type with five different
--   constructors. Our representation is as a tagged array of pointers: For
--   <tt>Constr</tt>, we have a constructor tag and a pointer to a
--   <tt>list</tt> structure For <tt>Map</tt>, we have a pointer to a
--   <tt>list</tt> structure For <tt>List</tt>, we have a pointer to a
--   <tt>list</tt> structure For <tt>I</tt>, we have an integer value For
--   <tt>B</tt>, we have a pointer to a <tt>bytestring</tt> structure
dataTyDef :: Type

-- | <a>dataTy</a> is a <a>Type</a> for data values.
dataTy :: Type

-- | <a>dataTyPtr</a> is a <a>Type</a> representing a pointer to a data
--   value.
dataTyPtr :: Type

-- | <a>gmpTyDef</a> attempts to capture the structure of
--   <tt>__mpz_struct</tt> from the gmp library.
gmpTyDef :: Type
emptyGmpTy :: Constant

-- | <a>gmpTy</a> is equivalent to <tt>mpz_t</tt> from the gmp library.
gmpTy :: Type

-- | <a>gmpTyPtr</a> is a pointer to <a>gmpTy</a>.
gmpTyPtr :: Type

-- | <a>closureTy</a> is a <a>Type</a> for closures.
closureTy :: Type

-- | <a>closureTyPtr</a> is a <a>Type</a> representing a pointer to a
--   closure.
closureTyPtr :: Type

-- | Enumerates different kinds of pointers we may have:
--   
--   <ul>
--   <li><a>StaticPtr</a> is guaranteed to represent a pointer to a static
--   global</li>
--   <li><a>DynamicPtr</a> _may_ represent a pointer to a dynamically
--   allocated value.</li>
--   </ul>
--   
--   In other words, we use <a>StaticPtr</a> when we know what sort of
--   pointer we have and <a>DynamicPtr</a> in other cases.
data PtrKind
StaticPtr :: PtrKind
DynamicPtr :: PtrKind

-- | Represents a pointer to a closure.
data ClosurePtr (k :: PtrKind)
[MkClosurePtr] :: Operand -> ClosurePtr 'DynamicPtr
[MkStaticClosurePtr] :: Constant -> ClosurePtr 'StaticPtr
class FromClosurePtr k to

-- | <a>closurePtr</a> <tt>closurePtr</tt> returns <tt>closurePtr</tt>'s
--   underlying LLVM representation.
closurePtr :: FromClosurePtr k to => ClosurePtr k -> to

-- | <a>toDynamicPtr</a> <tt>closurePtr</tt> turns a closure pointer into a
--   dynamic closure pointer. This is conceptually a no-op and just allows
--   us to forget information in case we only need a <a>DynamicPtr</a>, but
--   have a <a>StaticPtr</a> or don't know which one we have. Static
--   pointers are always acceptable where dynamic pointers are expected.
toDynamicPtr :: ClosurePtr k -> ClosurePtr 'DynamicPtr

-- | <a>contTy</a> is a <a>Type</a> for continuations.
contTy :: Type

-- | <a>contTyPtr</a> is a <a>Type</a> representing a pointer to a
--   continuation.
contTyPtr :: Type

-- | Represents pointers to continuations.
newtype Continuation
MkCont :: Operand -> Continuation
[contPtr] :: Continuation -> Operand

-- | Local variables can be closures or continuations.
data Local
LocalClosure :: ClosurePtr 'DynamicPtr -> Local
LocalCont :: Continuation -> Local

-- | <a>localOperand</a> <tt>local</tt> retrieves the underlying
--   <a>Operand</a> of <tt>local</tt>.
localOperand :: Local -> Operand
instance GHC.Show.Show Hachi.Compiler.CodeGen.Types.ListPtr
instance GHC.Classes.Eq Hachi.Compiler.CodeGen.Types.ListPtr
instance GHC.Show.Show Hachi.Compiler.CodeGen.Types.Continuation
instance GHC.Classes.Eq Hachi.Compiler.CodeGen.Types.Continuation
instance GHC.Show.Show Hachi.Compiler.CodeGen.Types.Local
instance GHC.Classes.Eq Hachi.Compiler.CodeGen.Types.Local
instance GHC.Classes.Eq (Hachi.Compiler.CodeGen.Types.ClosurePtr k)
instance GHC.Show.Show (Hachi.Compiler.CodeGen.Types.ClosurePtr k)
instance Hachi.Compiler.CodeGen.Types.FromClosurePtr 'Hachi.Compiler.CodeGen.Types.StaticPtr LLVM.AST.Constant.Constant
instance Hachi.Compiler.CodeGen.Types.FromClosurePtr k LLVM.AST.Operand.Operand

module Hachi.Compiler.CodeGen.Monad

-- | Enumerates all supported types of constants. This would technically be
--   a great candidate for a data family, but we'd then end up with some
--   mutually recursive modules, unless we shuffle things around a bunch.
data ConstantTy
ConstInteger :: ConstantTy
ConstByteString :: ConstantTy
ConstText :: ConstantTy
ConstUnit :: ConstantTy
ConstBool :: ConstantTy
ConstData :: ConstantTy
ConstPair :: ConstantTy
ConstList :: ConstantTy

-- | Represents the state of the code generator.
data CodeGenSt
MkCodeGenSt :: Config -> Constant -> IORef (Map String (IORef Integer)) -> Map Text Local -> Map DefaultFun (ClosurePtr 'StaticPtr) -> IORef (Map ConstantTy Constant) -> IORef (Map ConstantTy Constant) -> IORef (Maybe Constant) -> Set (Text, Bool) -> CodeGenSt

-- | The configuration for the compiler.
[codeGenCfg] :: CodeGenSt -> Config
[codeGenErrMsg] :: CodeGenSt -> Constant
[codeGenCounters] :: CodeGenSt -> IORef (Map String (IORef Integer))
[codeGenEnv] :: CodeGenSt -> Map Text Local
[codeGenBuiltins] :: CodeGenSt -> Map DefaultFun (ClosurePtr 'StaticPtr)
[codeGenConstEntries] :: CodeGenSt -> IORef (Map ConstantTy Constant)
[codeGenConstPrinters] :: CodeGenSt -> IORef (Map ConstantTy Constant)
[codeGenFunPrinter] :: CodeGenSt -> IORef (Maybe Constant)
[codeGenFreeVars] :: CodeGenSt -> Set (Text, Bool)

-- | The code generator monad.
newtype CodeGen m a
MkCodeGen :: ReaderT CodeGenSt m a -> CodeGen m a
[runCodeGen] :: CodeGen m a -> ReaderT CodeGenSt m a

-- | A constraint synonym for the type class constraints we usually expect
--   our code generation monad to satisfy.
type MonadCodeGen m = (MonadIO m, MonadFail m, MonadModuleBuilder m, MonadReader CodeGenSt m, MonadFix m)

-- | <a>mkFresh</a> <tt>prefix</tt> generates a fresh name starting with
--   <tt>prefix</tt>.
mkFresh :: (MonadReader CodeGenSt m, MonadIO m) => String -> m String

-- | <a>extendScope</a> <tt>name operand action</tt> adds <tt>name</tt> to
--   the scope for <tt>action</tt> along with <tt>operand</tt> which
--   represents the LLVM identifier.
extendScope :: MonadReader CodeGenSt m => Text -> Local -> m a -> m a

-- | <a>updateEnv</a> <tt>names operands action</tt> updates the scope for
--   <tt>action</tt> with <tt>operands</tt> which correspond to
--   <tt>names</tt>. Important: the names in <tt>names</tt> must be in the
--   same order as the corresponding entries in <tt>operands</tt>.
updateEnv :: MonadReader CodeGenSt m => Set Text -> [Local] -> m a -> m a

-- | <a>localFreeVars</a> <tt>freeVars</tt> sets the set of free variables
--   in the current compilation scope to <tt>freeVars</tt>.
localFreeVars :: MonadReader CodeGenSt m => Set (Text, Bool) -> m a -> m a

-- | <a>currentFreeVars</a> is a computation which retrieves the set of
--   free variables in the current compilation scope.
currentFreeVars :: MonadReader CodeGenSt m => m (Set (Text, Bool))
instance GHC.Show.Show Hachi.Compiler.CodeGen.Monad.ConstantTy
instance GHC.Classes.Ord Hachi.Compiler.CodeGen.Monad.ConstantTy
instance GHC.Classes.Eq Hachi.Compiler.CodeGen.Monad.ConstantTy
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Hachi.Compiler.CodeGen.Monad.CodeGen m)
instance LLVM.IRBuilder.Monad.MonadIRBuilder m => LLVM.IRBuilder.Monad.MonadIRBuilder (Hachi.Compiler.CodeGen.Monad.CodeGen m)
instance LLVM.IRBuilder.Module.MonadModuleBuilder m => LLVM.IRBuilder.Module.MonadModuleBuilder (Hachi.Compiler.CodeGen.Monad.CodeGen m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader Hachi.Compiler.CodeGen.Monad.CodeGenSt (Hachi.Compiler.CodeGen.Monad.CodeGen m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Hachi.Compiler.CodeGen.Monad.CodeGen m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hachi.Compiler.CodeGen.Monad.CodeGen m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hachi.Compiler.CodeGen.Monad.CodeGen m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hachi.Compiler.CodeGen.Monad.CodeGen m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hachi.Compiler.CodeGen.Monad.CodeGen m)

module Hachi.Compiler.CodeGen.Constant.Text

-- | <a>strlen</a> <tt>str</tt> generates code which implements the same
--   behaviour as the <tt>strlen</tt> function. I.e. it computes the length
--   of <tt>str</tt>.
strlen :: (MonadCodeGen m, MonadIRBuilder m) => Operand -> m Operand

-- | <a>strcpy</a> <tt>dest src</tt> copies the string from <tt>src</tt> to
--   @dest.
strcpy :: (MonadCodeGen m, MonadIRBuilder m) => Operand -> Operand -> m Operand

-- | <a>streq</a> <tt>s0 s1</tt> computes if <tt>s0</tt> and <tt>s1</tt>
--   are equal.
streq :: (MonadCodeGen m, MonadIRBuilder m) => Operand -> Operand -> m Operand


-- | This module provides convenience functions for constructing LLVM IR,
--   including more flexible versions of functions found in
--   <a>IRBuilder</a>.
module Hachi.Compiler.CodeGen.IRBuilder
array :: (HasCallStack, MonadModuleBuilder m) => [Constant] -> m Operand
struct :: Maybe Name -> Bool -> [Constant] -> Operand
half :: Word16 -> Operand
single :: Float -> Operand
double :: Double -> Operand
bit :: Integer -> Operand
int8 :: Integer -> Operand
int16 :: Integer -> Operand
int32 :: Integer -> Operand
int64 :: Integer -> Operand
sizeof :: (HasCallStack, MonadIRBuilder m, MonadModuleBuilder m) => Word32 -> Type -> m Operand

-- | See <a>reference</a>.
unreachable :: MonadIRBuilder m => m ()

-- | Conditional branch (see <a>br</a> for unconditional instructions). See
--   <a>reference</a>.
condBr :: MonadIRBuilder m => Operand -> Name -> Name -> m ()

-- | See <a>reference</a>.
select :: (HasCallStack, MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> Operand -> m Operand

-- | See <a>reference</a>.
switch :: MonadIRBuilder m => Operand -> Name -> [(Constant, Name)] -> m ()

-- | See <a>reference</a>.
ret :: MonadIRBuilder m => Operand -> m ()

-- | Emit a <tt>ret void</tt> instruction. See <a>reference</a>.
retVoid :: MonadIRBuilder m => m ()

-- | See <a>reference</a>.
phi :: (HasCallStack, MonadIRBuilder m, MonadModuleBuilder m) => [(Operand, Name)] -> m Operand

-- | Unconditional branch. Emit a <tt>br label <a>dest</a></tt> instruction
--   See <a>reference</a>.
br :: MonadIRBuilder m => Name -> m ()

-- | See <a>reference</a>.
fcmp :: MonadIRBuilder m => FloatingPointPredicate -> Operand -> Operand -> m Operand

-- | See <a>reference</a>.
icmp :: MonadIRBuilder m => IntegerPredicate -> Operand -> Operand -> m Operand

-- | See <a>reference</a>.
insertValue :: (HasCallStack, MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> [Word32] -> m Operand

-- | See <a>reference</a>.
extractValue :: (HasCallStack, MonadIRBuilder m, MonadModuleBuilder m) => Operand -> [Word32] -> m Operand

-- | See <a>reference</a>.
shuffleVector :: (HasCallStack, MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> [Int32] -> m Operand

-- | See <a>reference</a>.
insertElement :: (HasCallStack, MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> Operand -> m Operand

-- | See <a>reference</a>.
extractElement :: (HasCallStack, MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | Emit the <tt>bitcast ... to</tt> instruction. See <a>reference</a>.
bitcast :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>inttoptr ... to</tt> instruction. See <a>reference</a>.
inttoptr :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>ptrtoint ... to</tt> instruction. See <a>reference</a>.
ptrtoint :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>sitofp ... to</tt> instruction. See <a>reference</a>.
sitofp :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>uitofp ... to</tt> instruction. See <a>reference</a>.
uitofp :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>fpext ... to</tt> instruction. See <a>reference</a>.
fpext :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>fptosi ... to</tt> instruction. See <a>reference</a>.
fptosi :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>fptoui ... to</tt> instruction. See <a>reference</a>.
fptoui :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>sext ... to</tt> instruction. See <a>reference</a>.
sext :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>zext ... to</tt> instruction. See <a>reference</a>.
zext :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>fptrunc ... to</tt> instruction. See <a>reference</a>.
fptrunc :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>trunc ... to</tt> instruction. See <a>reference</a>.
trunc :: MonadIRBuilder m => Operand -> Type -> m Operand

-- | Emit the <tt>getelementptr</tt> instruction. See <a>reference</a>.
gep :: (HasCallStack, MonadIRBuilder m, MonadModuleBuilder m) => Operand -> [Operand] -> m Operand

-- | See <a>reference</a>.
store :: MonadIRBuilder m => Operand -> Word32 -> Operand -> m ()

-- | See <a>reference</a>.
load :: (HasCallStack, MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Word32 -> m Operand

-- | See <a>reference</a>.
alloca :: MonadIRBuilder m => Type -> Maybe Operand -> Word32 -> m Operand

-- | See <a>reference</a>.
xor :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
or :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
and :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
ashr :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
lshr :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
shl :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
srem :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
urem :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
sdiv :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
udiv :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
sub :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
mul :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
add :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
frem :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
fdiv :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
fsub :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
fmul :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
fadd :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> Operand -> m Operand

-- | See <a>reference</a>.
fneg :: (MonadIRBuilder m, MonadModuleBuilder m) => Operand -> m Operand

-- | Convenience function for module construction (transformer version)
buildModuleT :: Monad m => ShortByteString -> ModuleBuilderT m a -> m Module

-- | Convenience function for module construction
buildModule :: ShortByteString -> ModuleBuilder a -> Module

-- | A named type definition
typedef :: MonadModuleBuilder m => Name -> Maybe Type -> m Type

-- | An external variadic argument function definition
externVarArgs :: MonadModuleBuilder m => Name -> [Type] -> Type -> m Operand

-- | An external function definition
extern :: MonadModuleBuilder m => Name -> [Type] -> Type -> m Operand
emitDefn :: MonadModuleBuilder m => Definition -> m ()

-- | Evaluate <a>ModuleBuilderT</a> to a list of definitions
execModuleBuilderT :: Monad m => ModuleBuilderState -> ModuleBuilderT m a -> m [Definition]

-- | Evaluate <a>ModuleBuilder</a> to a list of definitions
execModuleBuilder :: ModuleBuilderState -> ModuleBuilder a -> [Definition]

-- | Evaluate <a>ModuleBuilderT</a> to a result and a list of definitions
runModuleBuilderT :: Monad m => ModuleBuilderState -> ModuleBuilderT m a -> m (a, [Definition])

-- | Evaluate <a>ModuleBuilder</a> to a result and a list of definitions
runModuleBuilder :: ModuleBuilderState -> ModuleBuilder a -> (a, [Definition])
emptyModuleBuilder :: ModuleBuilderState
newtype ModuleBuilderT (m :: Type -> Type) a
ModuleBuilderT :: StateT ModuleBuilderState m a -> ModuleBuilderT (m :: Type -> Type) a
[unModuleBuilderT] :: ModuleBuilderT (m :: Type -> Type) a -> StateT ModuleBuilderState m a
data ModuleBuilderState
ModuleBuilderState :: SnocList Definition -> Map Name Type -> ModuleBuilderState
[builderDefs] :: ModuleBuilderState -> SnocList Definition
[builderTypeDefs] :: ModuleBuilderState -> Map Name Type
type ModuleBuilder = ModuleBuilderT Identity
class Monad m => MonadModuleBuilder (m :: Type -> Type)
liftModuleState :: MonadModuleBuilder m => State ModuleBuilderState a -> m a

-- | A parameter name suggestion
data ParameterName
NoParameterName :: ParameterName
ParameterName :: ShortByteString -> ParameterName

-- | Find out if the currently active block has a terminator.
--   
--   This function will fail under the same condition as
--   <tt>currentBlock</tt>
hasTerminator :: (HasCallStack, MonadIRBuilder m) => m Bool

-- | Get the name of the currently active block.
--   
--   This function will throw an error if there is no active block. The
--   only situation in which this can occur is if it is called before any
--   call to <a>block</a> and before emitting any instructions.
currentBlock :: (HasCallStack, MonadIRBuilder m) => m Name

-- | <tt>ir <a>named</a> name</tt> executes the <a>IRBuilder</a>
--   <tt>ir</tt> using <tt>name</tt> as the base name whenever a fresh
--   local name is generated. Collisions are avoided by appending numbers
--   (first <tt>"name"</tt>, then <tt>"name1"</tt>, <tt>"name2"</tt>, and
--   so on).
named :: MonadIRBuilder m => m r -> ShortByteString -> m r

-- | Starts a new block and ends the previous one
block :: MonadIRBuilder m => m Name

-- | Starts a new block labelled using the given name and ends the previous
--   one. The name is assumed to be fresh.
emitBlockStart :: MonadIRBuilder m => Name -> m ()

-- | Emit terminator
emitTerm :: MonadIRBuilder m => Terminator -> m ()

-- | Emit instruction that returns void
emitInstrVoid :: MonadIRBuilder m => Instruction -> m ()

-- | Emit instruction
emitInstr :: MonadIRBuilder m => Type -> Instruction -> m Operand

-- | Generate a fresh numbered name
freshUnName :: MonadIRBuilder m => m Name

-- | Generate a fresh name from a name suggestion
freshName :: MonadIRBuilder m => ShortByteString -> m Name

-- | Generate a fresh name. The resulting name is numbered or based on the
--   name suggested with <a>named</a> if that's used.
fresh :: MonadIRBuilder m => m Name
modifyBlock :: MonadIRBuilder m => (PartialBlock -> PartialBlock) -> m ()

-- | If no partial block exists, create a new block with a fresh label.
--   
--   This is useful if you want to ensure that the label for the block is
--   assigned before another label which is not possible with
--   <a>modifyBlock</a>.
ensureBlock :: MonadIRBuilder m => m ()

-- | Evaluate IRBuilderT to a list of basic blocks
execIRBuilderT :: Monad m => IRBuilderState -> IRBuilderT m a -> m [BasicBlock]

-- | Evaluate IRBuilder to a list of basic blocks
execIRBuilder :: IRBuilderState -> IRBuilder a -> [BasicBlock]

-- | Evaluate IRBuilderT to a result and a list of basic blocks
runIRBuilderT :: Monad m => IRBuilderState -> IRBuilderT m a -> m (a, [BasicBlock])

-- | Evaluate IRBuilder to a result and a list of basic blocks
runIRBuilder :: IRBuilderState -> IRBuilder a -> (a, [BasicBlock])
emptyIRBuilder :: IRBuilderState
emptyPartialBlock :: Name -> PartialBlock

-- | This provides a uniform API for creating instructions and inserting
--   them into a basic block: either at the end of a BasicBlock, or at a
--   specific location in a block.
newtype IRBuilderT (m :: Type -> Type) a
IRBuilderT :: StateT IRBuilderState m a -> IRBuilderT (m :: Type -> Type) a
[unIRBuilderT] :: IRBuilderT (m :: Type -> Type) a -> StateT IRBuilderState m a
type IRBuilder = IRBuilderT Identity
class Monad m => MonadIRBuilder (m :: Type -> Type)
liftIRState :: MonadIRBuilder m => State IRBuilderState a -> m a

-- | A partially constructed block as a sequence of instructions
data PartialBlock
PartialBlock :: !Name -> SnocList (Named Instruction) -> First (Named Terminator) -> PartialBlock
[partialBlockName] :: PartialBlock -> !Name
[partialBlockInstrs] :: PartialBlock -> SnocList (Named Instruction)
[partialBlockTerm] :: PartialBlock -> First (Named Terminator)

-- | Builder monad state
data IRBuilderState
IRBuilderState :: !Word -> !Map ShortByteString Word -> !Maybe ShortByteString -> SnocList BasicBlock -> !Maybe PartialBlock -> IRBuilderState
[builderSupply] :: IRBuilderState -> !Word
[builderUsedNames] :: IRBuilderState -> !Map ShortByteString Word
[builderNameSuggestion] :: IRBuilderState -> !Maybe ShortByteString
[builderBlocks] :: IRBuilderState -> SnocList BasicBlock
[builderBlock] :: IRBuilderState -> !Maybe PartialBlock

-- | <a>setLinkage</a> <tt>linkage global</tt> sets <tt>global</tt>'s
--   linkage type to <tt>linkage</tt>.
setLinkage :: Linkage -> Global -> Global
class HasCC a

-- | <a>setCC</a> <tt>cc object</tt> sets the calling convention of
--   <tt>object</tt> to <tt>cc</tt>.
setCC :: HasCC a => CallingConvention -> a -> a
class HasReturnAttr a

-- | <a>setReturnAttr</a> <tt>attributes object</tt> sets the return
--   attributes of <tt>object</tt> to <tt>attributes</tt>.
setReturnAttr :: HasReturnAttr a => [ParameterAttribute] -> a -> a
class HasFunctionAttr a

-- | <a>setFunctionAttr</a> <tt>attributes object</tt> sets the function
--   attributes of <tt>object</tt> to <tt>attributes</tt>.
setFunctionAttr :: HasFunctionAttr a => [Either GroupID FunctionAttribute] -> a -> a
class HasMetadata a

-- | <a>setMetadata</a> <tt>metadata object</tt> sets the metadata of
--   <tt>object</tt> to <tt>metadata</tt>.
setMetadata :: HasMetadata a => [(ShortByteString, MDRef MDNode)] -> a -> a

-- | <a>plcFunOpts</a> <tt>global</tt> applies the default function
--   settings we use for PLC code to <tt>global</tt>.
plcFunOpts :: Global -> Global

-- | <a>global</a> <tt>name type initialValue transformation</tt> emits a
--   new global named <tt>name</tt> of <tt>type</tt> with an initial value
--   of <tt>initialValue</tt>. Additionally, <tt>transformation</tt> is
--   applied to the global before it is emitted, so that arbitrary
--   transformations can be performed on it.
global :: MonadModuleBuilder m => Name -> Type -> Constant -> (Global -> Global) -> m Operand

-- | <a>globalStringPtr</a> <tt>string name transformation</tt> emits a new
--   global string constant named <tt>name</tt> with a value of
--   <tt>string</tt>. The <tt>transformation</tt> is applied to the
--   <a>Global</a> before it is emitted.
globalStringPtr :: (MonadModuleBuilder m, MonadFail m) => String -> Name -> (Global -> Global) -> m Constant

-- | <a>function</a> <tt>name parameters returnType transformation
--   bodyBuilder</tt> emits a new function named <tt>name</tt>.
function :: MonadModuleBuilder m => Name -> [(Type, ParameterName)] -> Type -> (Global -> Global) -> ([Operand] -> IRBuilderT m ()) -> m Operand

-- | <a>plcCall</a> <tt>instruction</tt> modified a <a>Call</a> instruction
--   so that it is suitable for calls to PLC functions.
plcCall :: Instruction -> Instruction

-- | <a>call</a> <tt>function arguments transformation</tt> emits a new
--   <a>Call</a> instruction for a call to <tt>function</tt> with
--   <tt>arguments</tt>. The <tt>transformation</tt> is applied to the
--   <a>Call</a> instruction before it is emitted.
call :: (HasCallStack, MonadFail m, MonadIRBuilder m, MonadModuleBuilder m) => Operand -> [(Operand, [ParameterAttribute])] -> (Instruction -> Instruction) -> m Operand

-- | <a>castIfNeeded</a> <tt>type ptr</tt> casts the type of <tt>ptr</tt>
--   to <tt>type</tt>, but only if it is not already <tt>type</tt>.
castIfNeeded :: (MonadModuleBuilder m, MonadIRBuilder m) => Type -> Operand -> m Operand

-- | <a>castToClosure</a> <tt>ptr</tt> casts the type of <tt>ptr</tt> to
--   <tt>closureTyPtr</tt>, but only if it is not already
--   <tt>closureTyPtr</tt>.
castToClosure :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> m Operand
instance Hachi.Compiler.CodeGen.IRBuilder.HasMetadata LLVM.AST.Global.Global
instance Hachi.Compiler.CodeGen.IRBuilder.HasMetadata LLVM.AST.Instruction.Instruction
instance Hachi.Compiler.CodeGen.IRBuilder.HasFunctionAttr LLVM.AST.Global.Global
instance Hachi.Compiler.CodeGen.IRBuilder.HasFunctionAttr LLVM.AST.Instruction.Instruction
instance Hachi.Compiler.CodeGen.IRBuilder.HasReturnAttr LLVM.AST.Global.Global
instance Hachi.Compiler.CodeGen.IRBuilder.HasReturnAttr LLVM.AST.Instruction.Instruction
instance Hachi.Compiler.CodeGen.IRBuilder.HasCC LLVM.AST.Global.Global
instance Hachi.Compiler.CodeGen.IRBuilder.HasCC LLVM.AST.Instruction.Instruction

module Hachi.Compiler.TH

-- | <a>mkGlobalStrRefs</a> <tt>globals</tt> generates LLVM
--   <a>Constant</a>s which refer to global string variables specified by
--   <tt>globals</tt>.
mkGlobalStrRefs :: [(String, String)] -> Q [Dec]
mkExternal :: String -> String -> Name -> Q [Dec]

module Hachi.Compiler.CodeGen.Globals

-- | <a>generateConstantGlobals</a> is a computation which emits global
--   definitions related to constants.
generateConstantGlobals :: (MonadCodeGen m, MonadFail m) => m ()
emptyListRef :: Operand
consRef :: Operand
commaRef :: Operand
closeParenRef :: Operand
openParenRef :: Operand
spaceRef :: Operand
oomErrRef :: Operand
bsIndexErrRef :: Operand
unBDataErrRef :: Operand
unIDataErrRef :: Operand
unListDataErrRef :: Operand
unMapDataErrRef :: Operand
unConstrDataErrRef :: Operand
tailErrRef :: Operand
headErrRef :: Operand
dataMatchErrRef :: Operand
funErrRef :: Operand
forceErrRef :: Operand
dataByteStringRef :: Operand
dataIntegerRef :: Operand
dataListRef :: Operand
dataMapRef :: Operand
dataConstrRef :: Operand
unitRef :: Operand
falseRef :: Operand
trueRef :: Operand
hexFormatRef :: Operand
strFormatRef :: Operand
i64FormatRef :: Operand
nlRef :: Operand
returnRef :: Operand

module Hachi.Compiler.CodeGen.Externals.GMP
mpzInitSetStrFun :: Global
mpzInitSetStrRef :: Constant
mpzInitSetStr :: (MonadModuleBuilder m, MonadIRBuilder m) => Name -> Constant -> String -> m ()
mpzInitSetUIntFun :: Global
mpzInitSetUInt :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> m ()
mpzGetStrFun :: Global
mpzGetStr :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m Operand
mpzGetUIntFun :: Global
mpzGetUInt :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> m Operand
mpzAddFun :: Global
mpzAdd :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m ()
mpzSubFun :: Global
mpzSub :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m ()
mpzMulFun :: Global
mpzMul :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m ()
mpzCmpFun :: Global
mpzCmp :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> m Operand
mpzFDivQFun :: Global
mpzFDivQ :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m ()
mpzFDivRFun :: Global
mpzFDivR :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m ()
mpzTDivQFun :: Global
mpzTDivQ :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m ()
mpzTDivRFun :: Global
mpzTDivR :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m ()


-- | This module contains the types, declarations, and references to
--   external functions that we import from stdlib.
module Hachi.Compiler.CodeGen.Externals
externalDefinitions :: [Definition]
rtsInit :: (MonadModuleBuilder m, MonadIRBuilder m) => m ()

-- | The type of printf.
printfTy :: Type

-- | A <a>Constant</a> which provides a reference to the global printf
--   declaration.
printfRef :: Constant
printf :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> [Operand] -> m Operand
exitTy :: Type
exitRef :: Constant
exit :: (MonadModuleBuilder m, MonadIRBuilder m) => Integer -> m Operand
mallocTy :: Type
mallocRef :: Constant

-- | <a>malloc</a> <tt>type size</tt> generates code which calls
--   <tt>malloc</tt> to allocate <tt>size</tt>-many bytes. The return value
--   is cast to <tt>type</tt>, which should normally be a pointer to
--   something.
malloc :: (MonadModuleBuilder m, MonadIRBuilder m, MonadCodeGen m) => Type -> Operand -> m Operand
memcpyTy :: Type
memcpyRef :: Constant
memcpy :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m Operand
memcmp :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m Operand
sha2_256 :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> m Operand
sha3_256 :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> m Operand
blake2b :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> m Operand
verifySig :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m Operand
mpzInitSetStr :: (MonadModuleBuilder m, MonadIRBuilder m) => Name -> Constant -> String -> m ()
mpzInitSetUInt :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> m ()
mpzGetStr :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m Operand
mpzGetUInt :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> m Operand
mpzAdd :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m ()
mpzSub :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m ()
mpzMul :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m ()
mpzFDivQ :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m ()
mpzFDivR :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m ()
mpzTDivQ :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m ()
mpzTDivR :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> Operand -> m ()
mpzCmp :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> Operand -> m Operand

module Hachi.Compiler.CodeGen.Constant.Integer

-- | <a>newInteger</a> allocates new memory for a pointer to a gmp integer.
newInteger :: (MonadCodeGen m, MonadIRBuilder m) => m Operand

module Hachi.Compiler.CodeGen.Constant.ByteString

-- | <a>bsNewStruct</a> <tt>size</tt> generates code which allocates enough
--   space for a new bytestring structure and stores <tt>size</tt> in it.
--   The pointer to the new structure is returned. The data pointer of the
--   bytestring is not set and no memory is allocated for the data.
bsNewStruct :: (MonadCodeGen m, MonadIRBuilder m) => Operand -> m Operand

-- | <a>bsNew</a> <tt>size</tt> generates code which allocates enough space
--   for a new bytestring with <tt>size</tt>-many elements. The actual
--   memory allocated is greater than <tt>size</tt>, since we need to store
--   the size in the bytestring as well. This function performs the latter
--   task as well before returning the pointer to the new bytestring.
bsNew :: (MonadCodeGen m, MonadIRBuilder m) => Operand -> m Operand

-- | <a>bsLen</a> <tt>ptr</tt> generates code which loads the length of a
--   bytestring which is represented by <tt>ptr</tt>.
bsLen :: (MonadCodeGen m, MonadIRBuilder m) => Operand -> m Operand

-- | <a>bsDataPtr</a> <tt>ptr</tt> generates code which calculates the
--   address of the data component of a bytestring represented by
--   <tt>ptr</tt>.
bsDataPtr :: (MonadCodeGen m, MonadIRBuilder m) => Operand -> m Operand

-- | <a>bsPrint</a> <tt>str</tt> generates code which prints the bytestring
--   pointed at by <tt>str</tt> as a hexadecimal string to the standard
--   output.
bsPrint :: (MonadCodeGen m, MonadIRBuilder m) => Operand -> m ()

-- | <a>bsIndex</a> <tt>str ix</tt> checks that <tt>ix</tt> is a valid
--   index for the bytestring pointed at by <tt>str</tt> and, if so,
--   retrieves the character at the given index.
bsIndex :: (MonadCodeGen m, MonadIRBuilder m) => Operand -> Operand -> m Operand

-- | <a>bsEquals</a> <tt>s0 s1</tt> determines whether the two bytestrings
--   pointed at by <tt>s0</tt> and <tt>s1</tt> are equal or not.
bsEquals :: (MonadCodeGen m, MonadIRBuilder m) => Operand -> Operand -> m Operand
bsLessThan :: (MonadCodeGen m, MonadIRBuilder m) => Operand -> Operand -> m Operand
bsLessThanEquals :: (MonadCodeGen m, MonadIRBuilder m) => Operand -> Operand -> m Operand


-- | This module contains common code generation functions.
module Hachi.Compiler.CodeGen.Common

-- | <a>mkParamName</a> <tt>name</tt> converts a <a>Text</a> value into a
--   <a>ParameterName</a>.
mkParamName :: Text -> ParameterName

-- | <a>fatal</a> <tt>strRef args</tt> generates code which terminates
--   execution of the resulting program after displaying the string pointed
--   to by <tt>strRef</tt>. Optionally, if the string contains formatting
--   characters, <tt>args</tt> are used as values for those placeholders.
fatal :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> [Operand] -> m ()

-- | <a>ifTracing</a> <tt>action</tt> will execute <tt>action</tt> if
--   tracing is enabled.
ifTracing :: MonadCodeGen m => m () -> m ()

-- | <a>compileTrace</a> <tt>message arguments</tt> generates code which
--   prints <tt>message</tt> to the standard output. The <tt>message</tt>
--   string may contain formatting characters which will be substituted
--   with values from <tt>arguments</tt>. If tracing is not enabled in the
--   code generation configuration, no code is generated.
compileTrace :: (MonadCodeGen m, MonadIRBuilder m) => String -> [Operand] -> m ()

module Hachi.Compiler.CodeGen.Closure

-- | Represents a pointer to a closure.
data ClosurePtr (k :: PtrKind)
[MkClosurePtr] :: Operand -> ClosurePtr 'DynamicPtr
[MkStaticClosurePtr] :: Constant -> ClosurePtr 'StaticPtr

-- | <a>closureTyDef</a> is a <a>Type</a> definition for closures. Note the
--   layout is as follows:
--   
--   <ul>
--   <li>A pointer to the code for the closure.</li>
--   <li>A pointer to the print code for the closure.</li>
--   <li>Closure flags.</li>
--   <li>Zero or more free variables. (LLVM will accept more elements than
--   the array's indicated size)
--   <a>https://llvm.org/docs/LangRef.html#array-type</a></li>
--   </ul>
closureTyDef :: Type

-- | The minimum size of a closure in words.
closureSize :: Num a => a

-- | <a>closureTy</a> is a <a>Type</a> for closures.
closureTy :: Type

-- | <a>closureTyPtr</a> is a <a>Type</a> representing a pointer to a
--   closure.
closureTyPtr :: Type

-- | <a>mkEntryTy</a> <tt>arity</tt> generates a function signature for a
--   closure with <tt>arity</tt>-many parameters in addition to the
--   parameter that references the closure itself. In other words, the
--   resulting signature has 1+<tt>arity</tt> many parameters.
mkEntryTy :: Int -> Type

-- | <a>clsEntryTy</a> is the <a>Type</a> of closure entry functions.
clsEntryTy :: Type

-- | <a>clsEntryParams</a> <tt>varName</tt> constructs a list of parameters
--   for a closure's entry function, where <tt>varName</tt> is the name of
--   the variable being bound.
clsEntryParams :: Text -> [(Type, ParameterName)]
varEntryTy :: Type

-- | <a>printFnTy</a> is the <a>Type</a> of closure print functions. They
--   are similar to closure entry functions in that they take a pointer to
--   the current closure as argument, but return nothing.
printFnTy :: Type

-- | <a>mkClosureName</a> <tt>name</tt> returns the name of a closure for
--   <tt>name</tt>.
mkClosureName :: String -> Name

-- | <a>compileClosure</a> <tt>isPoly name entryPtr printPtr</tt> generates
--   a global variable representing a closure for <tt>name</tt>.
compileClosure :: MonadModuleBuilder m => Bool -> String -> Constant -> Constant -> [Constant] -> m (ClosurePtr 'StaticPtr)

-- | The size of a pointer as an <a>Operand</a>. This should correspond to
--   the value given by <a>bits</a>.
ptrSize :: Operand

-- | When we dynamically allocate closures, we need to know how much space
--   to allocate for the pointers; for this purpose we are currently
--   assuming that we are running on a 64-bit system.
bits :: Word32

-- | A class of types which represent runtime structures that contain free
--   variables.
class HasFreeVars ptr

-- | <a>loadFreeVar</a> <tt>ptr type index</tt> loads the free variable at
--   <tt>index</tt> of the closure-like structure pointed to by
--   <tt>ptr</tt>. If required, the resulting <a>Operand</a> is cast to
--   <tt>type</tt>.
loadFreeVar :: (HasFreeVars ptr, MonadModuleBuilder m, MonadIRBuilder m) => ptr -> Type -> Integer -> m Operand

-- | <a>allocateClosure</a> <tt>isDelay codePtr printPtr freeVars</tt>
--   allocates a closure with enough space to store all of
--   <tt>freeVars</tt> in addition to the code pointers. The code pointers
--   are free variables are stored in the closure and the pointer to the
--   closure is returned.
allocateClosure :: (MonadCodeGen m, MonadIRBuilder m) => Bool -> Constant -> Constant -> [Operand] -> m (ClosurePtr 'DynamicPtr)

-- | <a>withFreeVars</a> <tt>ptr computation</tt> runs <tt>computation</tt>
--   after retrieving all free variables from the closure-like structure
--   pointed to by <tt>ptr</tt>.
withFreeVars :: (HasFreeVars ptr, MonadCodeGen m, MonadIRBuilder m) => ptr -> m a -> m a

-- | <a>compileDynamicClosure</a> <tt>isDelay name freeVars var
--   codeFun</tt> generates code which dynamically creates a new closure
--   when executed. The static parts of the closure use <tt>name</tt>. The
--   set given by <tt>freeVars</tt> signals which variables should be
--   stored in the closure's free variables array. The name given by
--   <tt>var</tt> is the variable that is bound by this closure.
--   <tt>codeFun</tt> is a computation which generates the code for the
--   body of the closure. The function returns a <a>ClosurePtr</a>
--   representing the new closure.
compileDynamicClosure :: MonadCodeGen m => Bool -> String -> Set (Text, Bool) -> Text -> (Operand -> Operand -> Continuation -> IRBuilderT m ()) -> IRBuilderT m (ClosurePtr 'DynamicPtr)

-- | <a>compileFunPrint</a> is a computation which generates the shared
--   pretty-printing code for all function closures and returns a reference
--   to it.
compileFunPrint :: MonadCodeGen m => m Constant

-- | Enumerates different components of a closure.
data ClosureComponent
ClosureCode :: ClosureComponent
ClosurePrint :: ClosureComponent
ClosureFlags :: ClosureComponent
ClosureFreeVar :: Integer -> ClosureComponent

-- | <a>loadFromClosure</a> <tt>component type ptr</tt> loads the component
--   described by <tt>component</tt> from the closure represented by
--   <tt>ptr</tt> and casts its type to <tt>type</tt>.
loadFromClosure :: (MonadModuleBuilder m, MonadIRBuilder m) => ClosureComponent -> Type -> ClosurePtr k -> m Operand

-- | <a>callClosure</a> <tt>component ptr args</tt> loads the component
--   described by <tt>component</tt> from the closure represented by
--   <tt>ptr</tt>, assumes it is a function, and then calls it with
--   <tt>args</tt> as arguments.
callClosure :: (MonadFail m, MonadModuleBuilder m, MonadIRBuilder m) => ClosureComponent -> ClosurePtr k -> [Operand] -> m (ClosurePtr 'DynamicPtr)
enterClosure :: (MonadFail m, MonadModuleBuilder m, MonadIRBuilder m) => ClosurePtr k -> Continuation -> Maybe Operand -> m (ClosurePtr 'DynamicPtr)

-- | <a>printClosure</a> <tt>ptr</tt> invokes the pretty-printing function
--   of the closure represented by <tt>ptr</tt>.
printClosure :: (MonadFail m, MonadModuleBuilder m, MonadIRBuilder m) => ClosurePtr k -> m ()

-- | <a>compileApply</a> <tt>funClosure argClosure</tt> generates code
--   which causes the program to enter the closure represented by
--   <tt>funClosure</tt> with the argument given by <tt>argClosure</tt>.
compileApply :: (MonadFail m, MonadModuleBuilder m, MonadIRBuilder m) => Continuation -> ClosurePtr f -> ClosurePtr x -> m (ClosurePtr 'DynamicPtr)

-- | <a>lookupVar</a> <tt>name type</tt> generates code which retrieves the
--   variable named <tt>name</tt> from the local environment. If the
--   variable is not in scope, we generate code which prints an error at
--   runtime. For convenience, we cast the type of the resulting
--   <a>Operand</a> to <tt>type</tt>, which will normally be
--   <a>closureTyPtr</a>.
lookupVar :: (MonadCodeGen m, MonadIRBuilder m, MonadFail m) => Text -> Type -> m Operand

-- | <a>retClosure</a> <tt>closurePtr</tt> returns the pointer represented
--   by <tt>closurePtr</tt>.
retClosure :: (MonadModuleBuilder m, MonadIRBuilder m) => ClosurePtr k -> m ()
instance GHC.Show.Show Hachi.Compiler.CodeGen.Closure.ClosureComponent
instance GHC.Classes.Eq Hachi.Compiler.CodeGen.Closure.ClosureComponent
instance Hachi.Compiler.CodeGen.Closure.HasFreeVars (Hachi.Compiler.CodeGen.Types.ClosurePtr k)
instance Hachi.Compiler.CodeGen.Closure.HasFreeVars Hachi.Compiler.CodeGen.Types.Continuation

module Hachi.Compiler.CodeGen.Constant.Pair

-- | <a>newPair</a> <tt>fst snd</tt> generates code which constructs a new
--   pair value, where the first component is <tt>fst</tt> and the second
--   component is <tt>snd</tt>.
newPair :: (MonadCodeGen m, MonadIRBuilder m) => ClosurePtr p -> ClosurePtr q -> m Operand

-- | <a>getFst</a> <tt>pairPtr</tt> generates code which retrieves the
--   first component from the pair pointed at by <tt>pairPtr</tt>.
getFst :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> m (ClosurePtr 'DynamicPtr)

-- | <a>getSnd</a> <tt>pairPtr</tt> generates code which retrieves the
--   second component from the pair pointed at by <tt>pairPtr</tt>.
getSnd :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> m (ClosurePtr 'DynamicPtr)

module Hachi.Compiler.CodeGen.Constant.List

-- | <a>listNew</a> <tt>head tail</tt> generates code which allocates
--   enough space for a new list structure. <tt>head</tt> and <tt>tail</tt>
--   are then stored in this structure.
listNew :: (MonadCodeGen m, MonadIRBuilder m) => Operand -> Operand -> m Operand

-- | <a>getHead</a> <tt>listPtr</tt> generates code which retrieves the
--   head of the list pointed at by <tt>listPtr</tt>.
getHead :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> m (ClosurePtr 'DynamicPtr)

-- | <a>getTail</a> <tt>listPtr</tt> generates code which retrieves the
--   tail of the list pointed at by <tt>listPtr</tt>.
getTail :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> m (ClosurePtr 'DynamicPtr)

-- | <a>listCase</a> <tt>listPtr nullBuilder consBuilder</tt> generates
--   code which tests if <tt>listPtr</tt> is a pointer to null or to a cons
--   cell and uses <tt>nullBuilder</tt> and <tt>consBuilder</tt> to
--   generate code for the respective cases.
listCase :: MonadIRBuilder m => Operand -> m () -> m () -> m ()

module Hachi.Compiler.CodeGen.Constant.Data
data DataTag
DataConstr :: DataTag
DataMap :: DataTag
DataList :: DataTag
DataI :: DataTag
DataB :: DataTag

-- | <a>dataGlobal</a> <tt>name tag params</tt> constructs a new Data
--   global named <tt>name</tt>, for the constructor identified by
--   <tt>tag</tt> and with the parameters given by <tt>params</tt>.
dataGlobal :: MonadModuleBuilder m => Name -> DataTag -> [Constant] -> m Constant

-- | <a>newData</a> <tt>tag dataPtr extraData</tt> allocates a new Data
--   value on the heap for the constructor identified by <tt>tag</tt> where
--   the data pointer is given by <tt>dataPtr</tt> and an additional
--   argument by <tt>extraData</tt> which is normally empty or an extra tag
--   in the case of <a>DataConstr</a>.
newData :: (MonadCodeGen m, MonadIRBuilder m) => DataTag -> Operand -> Maybe Operand -> m Operand

-- | <a>withDataTag</a> <tt>ptr builder</tt> generates code which loads the
--   tag from <tt>ptr</tt> and then performs different actions, produced by
--   <tt>builder</tt>, depending on the tag value.
withDataTag :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> (DataTag -> m ()) -> m ()

-- | <a>loadDataTag</a> <tt>ptr</tt> retrieves the data tag from
--   <tt>ptr</tt>.
loadDataTag :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> m Operand

-- | <a>loadDataPtr</a> <tt>ptr</tt> retrieves the payload from the Data
--   value pointed at by <tt>ptr</tt>. This function works for all forms of
--   Data value.
loadDataPtr :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> m (ClosurePtr 'DynamicPtr)

-- | <a>loadConstrTag</a> <tt>ptr</tt> retrieves the constructor tag from a
--   Data value pointed at by <tt>ptr</tt>. This function assumes that the
--   Data value represents a data constructor and no such check is
--   performed.
loadConstrTag :: (MonadModuleBuilder m, MonadIRBuilder m) => Operand -> m (ClosurePtr 'DynamicPtr)
instance GHC.Show.Show Hachi.Compiler.CodeGen.Constant.Data.DataTag
instance GHC.Classes.Eq Hachi.Compiler.CodeGen.Constant.Data.DataTag


-- | This module contains definitions related to continuations.
module Hachi.Compiler.CodeGen.CPS

-- | <a>contEntryTy</a> is the <a>Type</a> of continuation entry functions.
contEntryTy :: Type

-- | <a>contTyDef</a> is the definition of the continuation closure type.
contTyDef :: Type

-- | <a>compileDynamicCont</a> <tt>name freeVars parameter builder</tt>
--   generates code which dynamically allocates a continuation closure.
compileDynamicCont :: MonadCodeGen m => String -> Set (Text, Bool) -> Text -> (Operand -> Operand -> IRBuilderT m ()) -> IRBuilderT m Continuation

-- | <a>cpsReturnOp</a> is a reference to the global identity continuation.
cpsReturnOp :: Operand

-- | <a>cpsReturnCont</a> is a reference to the global identity
--   continuation.
cpsReturnCont :: Continuation

-- | <a>compileCpsReturn</a> is a computation which generates code for the
--   identity continuation, which just returns its argument and makes no
--   further function calls. This is used to terminate a CPS style sequence
--   of function calls.
compileCpsReturn :: MonadCodeGen m => m Continuation

-- | <a>callCont</a> <tt>continuationPtr argument</tt> generates code which
--   calls the continuation pointed at by <tt>continuationPtr</tt> with the
--   <tt>argument</tt>.
callCont :: (ContinuationRep a, MonadCodeGen m, MonadIRBuilder m) => Continuation -> a -> m (ClosurePtr 'DynamicPtr)
instance Hachi.Compiler.CodeGen.CPS.ContinuationRep LLVM.AST.Operand.Operand
instance Hachi.Compiler.CodeGen.CPS.ContinuationRep (Hachi.Compiler.CodeGen.Types.ClosurePtr k)


-- | This module contains code generation functions for constants.
module Hachi.Compiler.CodeGen.Constant

-- | <a>generateConstantGlobals</a> is a computation which emits global
--   definitions related to constants.
generateConstantGlobals :: (MonadCodeGen m, MonadFail m) => m ()
forceErrRef :: Operand
class CompileConstant a

-- | <a>compileConst</a> <tt>value</tt> generates code for a constant whose
--   <tt>value</tt> is provided as the first argument.
compileConst :: (MonadCodeGen m, MonadIRBuilder m) => Some (ValueOf DefaultUni) -> m (ClosurePtr 'StaticPtr)

-- | <a>compileConstDynamic</a> <tt>value</tt> generates code which
--   allocates a dynamic closure for the value given by <tt>value</tt>.
--   Note that this function must be used with <tt>XTypeApplications</tt>
--   in order to select a type for the type variable <tt>a</tt>.
compileConstDynamic :: forall a m. (MonadCodeGen m, MonadIRBuilder m, CompileConstant a) => Operand -> m (ClosurePtr 'DynamicPtr)

-- | <a>retConstDynamic</a> <tt>value</tt> is like
--   <a>compileConstDynamic</a>, except that a return instruction is
--   inserted at the end which returns the pointer to the new closure.
retConstDynamic :: forall a m. (MonadCodeGen m, MonadIRBuilder m, CompileConstant a) => Continuation -> Operand -> m ()

-- | <a>loadConstVal</a> <tt>type</tt> loads the value of the result
--   register (which constant closures write to when entered) assuming that
--   it is of the type given by <tt>type</tt>.
loadConstVal :: (MonadModuleBuilder m, MonadIRBuilder m) => Type -> m Operand
instance Hachi.Compiler.CodeGen.Constant.CompileConstant GHC.Integer.Type.Integer
instance Hachi.Compiler.CodeGen.Constant.CompileConstant Data.ByteString.Internal.ByteString
instance Hachi.Compiler.CodeGen.Constant.CompileConstant Data.Text.Internal.Text
instance Hachi.Compiler.CodeGen.Constant.CompileConstant ()
instance Hachi.Compiler.CodeGen.Constant.CompileConstant GHC.Types.Bool
instance Hachi.Compiler.CodeGen.Constant.CompileConstant PlutusCore.Data.Data
instance (Hachi.Compiler.CodeGen.Constant.CompileConstant a, Hachi.Compiler.CodeGen.Constant.CompileConstant b) => Hachi.Compiler.CodeGen.Constant.CompileConstant (a, b)
instance Hachi.Compiler.CodeGen.Constant.CompileConstant a => Hachi.Compiler.CodeGen.Constant.CompileConstant [a]


-- | Code generation for functions we want to export when compiling to a
--   library.
module Hachi.Compiler.CodeGen.Library

-- | <a>emitLibraryApi</a> is a computation which generates all functions
--   that should be available as part of the library API. It also returns a
--   <a>String</a> value containing all of the C function signatures for
--   the API.
emitLibraryApi :: MonadCodeGen m => m String


-- | This module contains code generators for runtime, value equality
--   checks.
module Hachi.Compiler.CodeGen.Equality

-- | <a>eqData</a> is a computation which generates a function for
--   comparing <tt>Data</tt> values for value equality.
eqData :: (MonadCodeGen m, MonadIRBuilder m) => m Operand

module Hachi.Compiler.CodeGen.Builtin

-- | <a>compileBuiltins</a> is a computation which generates code for all
--   the built-in functions and returns a mapping from their tags to the
--   corresponding function pointers.
compileBuiltins :: MonadCodeGen m => m (Map DefaultFun (ClosurePtr 'StaticPtr))
instance Hachi.Compiler.CodeGen.Builtin.ToParams Data.Text.Internal.Text
instance Hachi.Compiler.CodeGen.Builtin.ToParams LLVM.AST.Type.Type

module Hachi.Compiler.CodeGen

-- | <a>generateCode</a> <tt>config path program</tt> generates code for
--   <tt>program</tt> using the configuration given by <tt>config</tt>.
generateCode :: Config -> Program Name DefaultUni DefaultFun () -> IO ()

module Hachi.Compiler
compile :: Config -> IO ()
